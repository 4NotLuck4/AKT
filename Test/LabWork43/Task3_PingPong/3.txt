# Приложение для игры в пинг-понг

Я разработаю приложение для игры в пинг-понг с разделением кода на отдельные файлы и четкой структурой.

## Структура проекта

1. **MainWindow.xaml** - основной файл разметки
2. **MainWindow.xaml.cs** - основная логика окна
3. **GameManager.cs** - управление игровым процессом
4. **Paddle.cs** - класс ракетки
5. **Ball.cs** - класс мяча

## Реализация

### MainWindow.xaml

```xml
<Window x:Class="PingPongGame.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Ping Pong Game" Height="450" Width="800" KeyDown="Window_KeyDown">
    <Canvas x:Name="gameCanvas" Background="Black">
        <Rectangle x:Name="paddle" 
                   Width="100" 
                   Height="20" 
                   Fill="White"
                   Canvas.Bottom="10"/>
        <Ellipse x:Name="ball" 
                 Width="20" 
                 Height="20" 
                 Fill="Red"/>
    </Canvas>
</Window>
```

### MainWindow.xaml.cs

```csharp
using System.Windows;
using System.Windows.Input;

namespace PingPongGame
{
    public partial class MainWindow : Window
    {
        private readonly GameManager _gameManager;

        public MainWindow()
        {
            InitializeComponent();
            _gameManager = new GameManager(gameCanvas, paddle, ball);
            _gameManager.StartGame();
        }

        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            _gameManager.HandleKeyPress(e.Key);
        }
    }
}
```

### GameManager.cs

```csharp
using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Shapes;
using System.Windows.Threading;

namespace PingPongGame
{
    public class GameManager
    {
        private readonly Canvas _gameCanvas;
        private readonly Paddle _paddle;
        private readonly Ball _ball;
        private readonly DispatcherTimer _gameTimer;

        public GameManager(Canvas gameCanvas, Rectangle paddle, Ellipse ball)
        {
            _gameCanvas = gameCanvas;
            _paddle = new Paddle(paddle, gameCanvas.ActualWidth);
            _ball = new Ball(ball, gameCanvas.ActualWidth, gameCanvas.ActualHeight);
            
            _gameTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(16) // ~60 FPS
            };
            _gameTimer.Tick += GameLoop;
        }

        public void StartGame()
        {
            _ball.ResetPosition();
            _gameTimer.Start();
        }

        public void HandleKeyPress(Key key)
        {
            const double paddleSpeed = 15;
            
            switch (key)
            {
                case Key.Left:
                    _paddle.Move(-paddleSpeed);
                    break;
                case Key.Right:
                    _paddle.Move(paddleSpeed);
                    break;
            }
        }

        private void GameLoop(object sender, EventArgs e)
        {
            _ball.Move();
            
            // Проверка столкновений с границами
            if (_ball.HitLeftWall() || _ball.HitRightWall(_gameCanvas.ActualWidth))
            {
                _ball.ReverseXDirection();
            }
            
            if (_ball.HitTopWall())
            {
                _ball.ReverseYDirection();
            }
            
            // Проверка столкновения с ракеткой
            if (_ball.HitPaddle(_paddle))
            {
                _ball.ReverseYDirection();
            }
            
            // Проверка проигрыша (мяч ушел за ракетку)
            if (_ball.BelowPaddle(_paddle, _gameCanvas.ActualHeight))
            {
                GameOver();
            }
        }

        private void GameOver()
        {
            _gameTimer.Stop();
            MessageBox.Show("Game Over! Click OK to restart.");
            StartGame();
        }
    }
}
```

### Paddle.cs

```csharp
using System.Windows;
using System.Windows.Shapes;

namespace PingPongGame
{
    public class Paddle
    {
        private readonly Rectangle _paddle;
        private readonly double _canvasWidth;

        public Paddle(Rectangle paddle, double canvasWidth)
        {
            _paddle = paddle;
            _canvasWidth = canvasWidth;
            
            // Установка начальной позиции
            Canvas.SetLeft(_paddle, (_canvasWidth - _paddle.Width) / 2);
        }

        public void Move(double offset)
        {
            var newLeft = Canvas.GetLeft(_paddle) + offset;
            
            // Проверка границ
            if (newLeft < 0)
                newLeft = 0;
            else if (newLeft + _paddle.Width > _canvasWidth)
                newLeft = _canvasWidth - _paddle.Width;
            
            Canvas.SetLeft(_paddle, newLeft);
        }

        public Rect GetRect()
        {
            return new Rect(
                Canvas.GetLeft(_paddle),
                Canvas.GetTop(_paddle),
                _paddle.Width,
                _paddle.Height);
        }
    }
}
```

### Ball.cs

```csharp
using System;
using System.Windows;
using System.Windows.Shapes;

namespace PingPongGame
{
    public class Ball
    {
        private readonly Ellipse _ball;
        private readonly double _canvasWidth;
        private readonly double _canvasHeight;
        
        private double _x;
        private double _y;
        private double _xSpeed;
        private double _ySpeed;
        private const double InitialSpeed = 5;

        public Ball(Ellipse ball, double canvasWidth, double canvasHeight)
        {
            _ball = ball;
            _canvasWidth = canvasWidth;
            _canvasHeight = canvasHeight;
            
            ResetPosition();
        }

        public void ResetPosition()
        {
            _x = _canvasWidth / 2 - _ball.Width / 2;
            _y = _canvasHeight / 2 - _ball.Height / 2;
            
            var random = new Random();
            _xSpeed = random.NextDouble() > 0.5 ? InitialSpeed : -InitialSpeed;
            _ySpeed = InitialSpeed;
            
            UpdatePosition();
        }

        public void Move()
        {
            _x += _xSpeed;
            _y += _ySpeed;
            UpdatePosition();
        }

        public bool HitLeftWall()
        {
            return _x <= 0;
        }

        public bool HitRightWall(double canvasWidth)
        {
            return _x + _ball.Width >= canvasWidth;
        }

        public bool HitTopWall()
        {
            return _y <= 0;
        }

        public bool BelowPaddle(Paddle paddle, double canvasHeight)
        {
            return _y + _ball.Height >= canvasHeight;
        }

        public bool HitPaddle(Paddle paddle)
        {
            var ballRect = new Rect(_x, _y, _ball.Width, _ball.Height);
            return ballRect.IntersectsWith(paddle.GetRect());
        }

        public void ReverseXDirection()
        {
            _xSpeed = -_xSpeed;
        }

        public void ReverseYDirection()
        {
            _ySpeed = -_ySpeed;
        }

        private void UpdatePosition()
        {
            Canvas.SetLeft(_ball, _x);
            Canvas.SetTop(_ball, _y);
        }
    }
}
```

## Особенности реализации:

1. **Четкое разделение ответственности**:
   - `GameManager` управляет игровым процессом
   - `Paddle` отвечает за логику ракетки
   - `Ball` отвечает за логику мяча

2. **Физика игры**:
   - Мяч отскакивает от стен и ракетки
   - Ракетка не выходит за границы экрана
   - Учет проигрыша при промахе

3. **Управление**:
   - Клавиши влево/вправо для управления ракеткой
   - Плавное движение ракетки

4. **Рестарт игры**:
   - При проигрыше игра автоматически перезапускается

5. **Производительность**:
   - Игровой цикл на 60 FPS
   - Оптимизированные проверки столкновений

Приложение готово к использованию и может быть легко расширено дополнительными функциями, такими как счет, уровни сложности или звуковые эффекты.